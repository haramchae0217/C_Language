    /*

    2장 상수와 데이터 출력

    문자는 작은 따옴표, 문자열은 큰 따옴표로 묶는다.
    정수는 4바이트, 실수는 8바이트의 크기로 변환
    문자 상수는 아스키 코드값 정수와 같은 형태로 변환
    맨 오른쪽 비트 = LSB 덜 중요한 비트
    맨 왼쪽 비트 = MSB 가장 중요한 비트
    
    실수상수 맨 왼쪽 부호비트 = 0이면 양수, 1이면 음수
    11bit까지는 지수 표현, 나머지 52bit는 소수 표현

    -2^(n-1) ~ 2^n-1 표현 가능
    ex) 8bit 
    => -2^7 ~ 2^7-1 
    => -128 ~ 127

    음수는 절댓값을 2의 보수로 바꾸어 변환
    ex) -10
    => 10을 2진수로 변환            0000000 00000000 00000000 00001010
    => 1의 보수를 취함              11111111 11111111 11111111 11110101 (현 숫자를 반전 0=>1, 1=>0)
    => 1의 보수를 취한 값에 1을 더함   11111111 11111111 11111111 11110110

    Bias 상수 (초과수)
  
    double : 부호비트    지수부 11bit      소수부 52bit
    float  : 부호비트    지수부 8bit       소수부 23bit

    -6.5 float
    110.1 정규화 1.101 * 2^2
    Bias상수 덧셈 127+2 = 129
    1 10000001 101000000000000000000

    -6.5 double
    110.1 정규화 1.101 * 2^2
    Bias상수 덧셈 1023 + 2 = 1025
    1 10000000001 10100000000000...

    float  4byte - 32bit 단정밀도 부동소수점 표현 신뢰할 수 있는 유효숫자는 6자리 표현
    double 8byte - 64bit 배정밀도 부동소수점 표현 신뢰할 수 있는 유효숫자는 15자리 표현
    
    3장 변수와 데이터 입력
    
    변수 선언 방법

    자료형과 변수명으로 선언

    전역변수는 선언시 자동으로 초기화가 됨
    선언한 자료형의 default값으로 초기화 
    int = 0
    float = 0.0f
    double = 0.0

    정적전역변수도 마찬가지로 자동 초기화

    대입연산자 = 는 왼쪽 변수에 오른쪽 값 저장
    a = 10;     변수에 상수 대입
    b = a;      변수에 변수 대입
    c = a+20;   변수에 수식 대입

    대입연산자 왼쪽 변수는 저장 공간, 오른쪽은 값이다.
    lValue, rValue
    a; = rValue
    a++; = rValue

    int i = 10, j=20;
    int *p, *q;
    
    p = &i; -> i의 주소값
    q = &j; -> j의 주소값

    *p = *q; -> i=20 
    *q = 100; -> j=100

    문자열 저장
    문자열은 char 배열에 저장
    
    char fruit[6] = "apple";
    배열의 크기는 \0(null문자)를 위해 1이상 크게 확보

    char* pstr = marloc(strof char * 6)
    strcpy(pstr,"apple")
    free(pstr)

    char fruit[20];
    fruit = "strawberry" => 불가능

    char fruit[20];
    strcpy(fruit, "strawberry") => 가능

    const를 사용한 변수는 초기값 수정 불가
    const int a = 10;
    a=20; => 불가능

    int *p = 5; => p가 가리키는 번지 값이 5
    *p = 10; => p가 가리키는 번지 값이 10으로 변경

    const int *p = 5;
    *p = 10; => 가리키는 번지의 값은 5 변경 불가
    but, 가리키는 주소는 변경 가능

    int * const p = 5;
    *p = 10; => 가리키는 번지의 값은 10으로 변경
    but, 가리키는 주소는 고정

    const int * const p = 5;
    번지의 값도 고정, 주소도 고정

    예약어 - 컴파일러와 약속된 단어
    변수명, 함수명 등에 사용

    식별자 - 사용자가 만든 단어
    유의미한 네이밍 필요
    알파벳, 숫자, _만사용
    숫자로 시작할 수 없음.

    nameing convention

    int a;

    scanf("%d", &a);
    print("%d",a)

    char str[100];
    scanf("%[^\n]s",str);

    scanf 문제점
    \n 값이 버퍼에 남아있기 때문에 바로 빈 값을 출력함.
    따라서 \n문자를 삭제시켜줘야 다음 scanf가 정상적으로 출력 가능
    1. getchar()
    2. rewind() 

    4장 연산자

    우선순위
    다운 캐스팅 불가
    업 캐스팅 가능

    산술연산자 / 대입연산자
    나누기연산자 / 나머지연산자

    묵시적 타입캐스팅
    명시적 타입캐스팅

    증감 연산자 전위 후위
    후위는 꼭 필요한 경우 아니면 피하는게 좋음

    관계연산자 = true or false로 출력
    int와 bool값은 호환이 된다.

    0은 거짓, 0아닌 모든건 참

    논리연산자 &&(and), ||(or), !(not)

    형변환
    int a = 20, b = 3;
    double res;

    res = ((double)a / b)

    sizeof 연산자 byte로 출력
    int a = 10;
    printf("int형 변수의 크기 : %d",sizeof(a)) => int형 변수의 크기 : 4

    복합대입 연산자

    콤마 연산자

    조건 연산자

    비트연산자
    &,^,|,~,>>,<<

    */